'''
MALT Dashboard Charting module
Uses the Plotly Python API to create charts based on a pandas dataframe.
'''

import pandas as pd
import plotly.offline
import plotly.graph_objs as go
# import plotly.figure_factory as FF  ## Switched to a HTML table generated by Pandas


## Plotly Chart generation functions
def LocationDistribution(df):
    ''' Plotly API call. Creates a histogram of cities, ordered from largest to smallest. Plotly does not have the
    capability to order bars in a histogram, so a new dataframe with the proper order is created
    and a Bar Chart is used. '''

    # Create City, State temporary dataframe
    tempdf = pd.DataFrame({'City, State': df['City'] + ', ' + df['State']})
    # Get counts of unique values
    citySeries = tempdf['City, State'].value_counts()
    # Create temporary dataframe for plotly to create a chart
    cityFrame = pd.DataFrame({'city' : citySeries.index, 'count' : citySeries.values})
    # Plotly chart
    trace = [
        go.Bar(
            x = cityFrame['city'],
            y = cityFrame['count'],
            text = "City: " + cityFrame['city'],
            marker = dict(
                color='rgb(158,202,225)',
                line=dict(
                    color='rgb(8,48,107)',
                    width=1.5,
                ),
            ),
        opacity=0.6,
        ),
    ]
    layout = go.Layout(
        margin = dict(
            l=50,
            r=50,
            t=10,
            b=50,
            ),
        xaxis = dict(
            showticklabels = True,
            tickmode = 'auto',
            tickfont = dict(
                size=10,
                ),
            ),
        )
    locations = go.Figure(data=trace, layout=layout)
    return plotly.offline.plot(
        locations,
        output_type='div',
        include_plotlyjs=False,
        show_link=False,
        )


def AccountDistribution(df):
    ''' Plotly API call. Creates a histogram of accounts, ordered from largest to smallest. Plotly does not have the
    capability to order bars in a histogram, so a new dataframe with the proper order is created
    and a Bar Chart is used. '''
    accountSeries = df["Account Name"].value_counts()
    accountFrame = pd.DataFrame({'accountName' : accountSeries.index, 'login count' : accountSeries.values})
    trace = [
        go.Bar(
            x = accountFrame["accountName"],
            y = accountFrame["login count"],
            #width = 0.9,
            text = "Account: " + accountFrame['accountName'],
            marker = dict(
                color='#fe9aa2',
                line=dict(
                    color='#fe3445',
                    width=1.5,
                    ),
                #colorbar = dict(
                #    thickness = 1,
                #   ),
                ),
            opacity=0.8,
            ),
        ]
    layout = go.Layout(
        margin = dict(
            l=50,
            r=50,
            t=10,
            b=50,
            ),
        xaxis = dict(
            #title = "Account Name",
            showticklabels = True,
            tickmode = 'auto',
            nticks = 10,
            tickfont = dict(
                size=10,
                ),
            ),
        yaxis = dict(
            #title = "Frequency"
            ),
    )
    accounts = go.Figure(data=trace, layout=layout)
    return plotly.offline.plot(
        accounts,
        output_type='div',
        include_plotlyjs=False,
        show_link=False,)



def TimeOfDayDistribution(df):
    ''' Plotly API call. Creates a histogram of all alerts by hour-of-day, ordered from 00:00 to 24:00.
    Plotly does not have the capability to order bars in a histogram, so a new dataframe with the
    proper order is created and a Bar Chart is used. Additionally, custom tick marks are used to
    show each bin as "xx:xx" rather than as a continuous variable. '''

    # Declare variables for layout below. I couldn't figure out how to create them inline within
    # the Plotly API code.
    hours_list = list(range(0,25))
    hours_format_list = []
    for x in range(0,25):
        hours_format_list.append('{}:00'.format(x))


    timeSeries = df["Datetime"].dt.hour.value_counts()
    timeFrame = pd.DataFrame({'Time':timeSeries.index, 'Count':timeSeries.values})
    trace = [
        go.Bar(
            x = timeFrame["Time"],
            y = timeFrame["Count"],
            #width = 0.9,
            marker = dict(
                color='	#f6d3a2',
                line=dict(
                    color='#eeb058',
                    width=1.5,
                ),
                #colorbar = dict(
                #    thickness = 1,
                #),
            ),
            opacity=1.0,
        ),
    ]
    layout = go.Layout(
        margin = dict(
            l=50,
            r=50,
            t=10,
            b=50,
            ),
        xaxis = dict(
            autotick = False,
            showticklabels = True,
            tickmode = 'array',
            tickvals = list(range(0,25)), ## Should be: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],
            ticktext = hours_format_list, ## Should be: ['0:00', '1:00', '2:00', '3:00', '4:00', '5:00', '6:00', '7:00', '8:00', '9:00', '10:00', '11:00', '12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00', '19:00', '20:00', '21:00', '22:00', '23:00', '24:00'],
            tickfont = dict(
                size=10,
                ),
            ),
        yaxis = dict(
            #title = "Frequency"
            ),
    )
    times = go.Figure(data=trace, layout=layout)
    return plotly.offline.plot(
        times,
        output_type='div',
        include_plotlyjs=False,
        show_link=False,
        )

def IPAddressDistributionToday(df):
    ''' Plotly API call. Creates a histogram of all alerts by hour-of-day, ordered from 00:00 to 24:00.
    Plotly does not have the capability to order bars in a histogram, so a new dataframe with the
    proper order is created and a Bar Chart is used. Additionally, custom tick marks are used to
    show each bin as "xx:xx" rather than as a continuous variable. '''

    ipSeries = df.loc[df.Datetime >= pd.to_datetime('today')]['IP Address'].value_counts()
    ipFrame = pd.DataFrame({'ipAddress' : ipSeries.index, 'login count' : ipSeries.values})
    trace = [
        go.Bar(
            x = ipFrame["ipAddress"],
            y = ipFrame["login count"],
            #width = 0.9,
            text = "IP Address: " + ipFrame['ipAddress'],
            marker = dict(
                color='#8dd775',
                line=dict(
                    color='#418a28',
                    width=1.5,
                    ),
                #colorbar = dict(
                #    thickness = 1,
                #   ),
                ),
            opacity=0.6,
            ),
        ]
    layout = go.Layout(
        margin = dict(
            l=50,
            r=50,
            t=10,
            b=50,
            ),
        xaxis = dict(
            #title = "Account Name",
            # showticklabels = True,
            # tickmode = 'auto',
            # nticks = 10,
            rangemode='nonnegative',
            autorange=True,
            tickfont = dict(
                size=10,
            ),
        ),
        yaxis = dict(
            #title = "Frequency"
        ),
    )
    accounts = go.Figure(data=trace, layout=layout)
    return plotly.offline.plot(
        accounts,
        output_type='div',
        include_plotlyjs=False,
        show_link=False,
        )


def DataTable(df):
    '''Creates a HTML table of records in the dataframe passed as argument df '''
    return df[['Account Name','Datetime','IP Address','City','State','Country','Latitude','Longitude']].to_html()

    # PLOTLY TABLE VERSION
    # dfTable = df[['Account Name','Country','State','City','Date','Time','IP Address',]]
    # table = FF.create_table(
    #     dfTable,
    #     colorscale = [[0, '#3D4A57'],
    #                   [.5, '#d9d9d9'],
    #                   [1, '#ffffff']],
    #     )
    # #table.layout.width = 1000 #width in px
    # return plotly.offline.plot(
    #     table,
    #     #filename='file.html',
    #     output_type='div',
    #     include_plotlyjs=False,
    #     show_link=False,
    #     )
